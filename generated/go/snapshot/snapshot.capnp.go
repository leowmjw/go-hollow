// Code generated by capnpc-go. DO NOT EDIT.

package snapshot

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Snapshot capnp.Struct

// Snapshot_TypeID is the unique identifier for the type Snapshot.
const Snapshot_TypeID = 0xe0b4e4d2a8069342

func NewSnapshot(s *capnp.Segment) (Snapshot, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Snapshot(st), err
}

func NewRootSnapshot(s *capnp.Segment) (Snapshot, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Snapshot(st), err
}

func ReadRootSnapshot(msg *capnp.Message) (Snapshot, error) {
	root, err := msg.Root()
	return Snapshot(root.Struct()), err
}

func (s Snapshot) String() string {
	str, _ := text.Marshal(0xe0b4e4d2a8069342, capnp.Struct(s))
	return str
}

func (s Snapshot) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Snapshot) DecodeFromPtr(p capnp.Ptr) Snapshot {
	return Snapshot(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Snapshot) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Snapshot) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Snapshot) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Snapshot) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Snapshot) Types() (TypeData_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return TypeData_List(p.List()), err
}

func (s Snapshot) HasTypes() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Snapshot) SetTypes(v TypeData_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTypes sets the types field to a newly
// allocated TypeData_List, preferring placement in s's segment.
func (s Snapshot) NewTypes(n int32) (TypeData_List, error) {
	l, err := NewTypeData_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return TypeData_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Snapshot_List is a list of Snapshot.
type Snapshot_List = capnp.StructList[Snapshot]

// NewSnapshot creates a new list of Snapshot.
func NewSnapshot_List(s *capnp.Segment, sz int32) (Snapshot_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Snapshot](l), err
}

// Snapshot_Future is a wrapper for a Snapshot promised by a client call.
type Snapshot_Future struct{ *capnp.Future }

func (f Snapshot_Future) Struct() (Snapshot, error) {
	p, err := f.Future.Ptr()
	return Snapshot(p.Struct()), err
}

type TypeData capnp.Struct

// TypeData_TypeID is the unique identifier for the type TypeData.
const TypeData_TypeID = 0xf289bb4e578b0911

func NewTypeData(s *capnp.Segment) (TypeData, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TypeData(st), err
}

func NewRootTypeData(s *capnp.Segment) (TypeData, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TypeData(st), err
}

func ReadRootTypeData(msg *capnp.Message) (TypeData, error) {
	root, err := msg.Root()
	return TypeData(root.Struct()), err
}

func (s TypeData) String() string {
	str, _ := text.Marshal(0xf289bb4e578b0911, capnp.Struct(s))
	return str
}

func (s TypeData) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TypeData) DecodeFromPtr(p capnp.Ptr) TypeData {
	return TypeData(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TypeData) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TypeData) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TypeData) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TypeData) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TypeData) TypeName() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s TypeData) HasTypeName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TypeData) TypeNameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s TypeData) SetTypeName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s TypeData) Records() (capnp.DataList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.DataList(p.List()), err
}

func (s TypeData) HasRecords() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TypeData) SetRecords(v capnp.DataList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewRecords sets the records field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s TypeData) NewRecords(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// TypeData_List is a list of TypeData.
type TypeData_List = capnp.StructList[TypeData]

// NewTypeData creates a new list of TypeData.
func NewTypeData_List(s *capnp.Segment, sz int32) (TypeData_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[TypeData](l), err
}

// TypeData_Future is a wrapper for a TypeData promised by a client call.
type TypeData_Future struct{ *capnp.Future }

func (f TypeData_Future) Struct() (TypeData, error) {
	p, err := f.Future.Ptr()
	return TypeData(p.Struct()), err
}

const schema_9eb32e19f86ee174 = "x\xdat\x8e\xbdJ\x03A\x14\x85\xcf\xb9\xb3\xc9F\xc8" +
	"J\x86\x08\xd1\xca\xc6\xc2\x80F\xd6\x9f\xc6F\x09\x16b" +
	"\x112(X\x0f\xebB\x9al\x96\xec\x82\xa4\xb2VK" +
	"{k{\xed|\x0b\x9f@\xc1\x17\xd0J\x0b\x19\x19\x91" +
	"\x08B\xba{\x0f\xf7~\xdfi\\\xed\x07q\xd4\x12\x88" +
	"Y\xacT]\xf7\xa6z\xf7\xf4\xfa\xf0\x0c\xdd\xa2+_" +
	"\xb2\x8f\xa5\xce\xfd-*\x0c\x81\xf8M\xa8\xbfB@\x7f" +
	"\xee\x81N\xcf]\x9f\xf6\x1e/\xdf\xff]J\x08l\xb5" +
	")l\xee\xf8\xa7f\xccs\xac\xbb\"\x19\xa4C[l" +
	"\xa8\"\xb3y1\x18\x95\x9d\xc4\xe6Y\xbe{\xfc\xbb\xa2" +
	"O\x9a@\x05@@@G\x9b\x80\xa9)\x9a\x15\xe1r" +
	"9\xc9\xd3\x82\xf3`_\x91\x8d?/\xe8\xc3\x99\xe8\x93" +
	"I\x9e\x1e\xd8\xd2\xfe\xa0kSt\xfb\x080\xab\x8af" +
	"[\xa8\xc9\x05\xfa0\xee\x02fM\xd1\x1c\x0a\x9d\xf7\xf5" +
	"\xec0\x05\xc0:\x84u\xf0b\x9c&\xa3\xf1\xd9\xb4E" +
	"\x04\xf1\xe3w\x00\x00\x00\xff\xff\xfalL\x1e"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_9eb32e19f86ee174,
		Nodes: []uint64{
			0xe0b4e4d2a8069342,
			0xf289bb4e578b0911,
		},
		Compressed: true,
	})
}
